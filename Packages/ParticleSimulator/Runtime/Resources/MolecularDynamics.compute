#pragma kernel ContactForceCS
#pragma kernel IntegrateCS

// 簡略化のためにスレッド数は1次元にしておく
#define THREAD_SIZE_X 32

#include "./Include/Particle.cginc"
#include "./Include/GridSearch.cginc"
#include "./Include/Terrain.cginc"
#include "./Include/Math.cginc"

// デバッグ用バッファ
RWStructuredBuffer<float4> _DebugBuffer;

// ▼ シェーダ定数の定義 -----------------------
cbuffer MolecularDynamicsCB
{
	float _TimeStep; // 時間刻み幅(dt)
	float3 _Gravity; // 重力
};
// ▲ シェーダ定数の定義 -----------------------


// ▼ ★ここから本体 --------------------------------------


inline float3 CalculateContactForce(float this_particle_radius, float3 this_particle_position, float3 this_particle_velocity,
									float other_particle_radius, float3 other_particle_position, float3 other_particle_velocity)
{
	float alpha = 0.5f;
	float beta = 1.5f;
	float kd = 200.0f;
	float kr = 10000.0f;
	float kt = 10000.0f;

	float3 vector_from_this_to_other = other_particle_position - this_particle_position;
	float offset_length = length(vector_from_this_to_other); // 粒子の中心間距離
	float xi = max(0, this_particle_radius + other_particle_radius - offset_length); // 粒子の重なり
	if (xi == 0)
		return 0; // 粒子が重なっていなければ接触力ゼロ

	float3 contact_force = float3(0, 0, 0);
	float3 normal = vector_from_this_to_other / offset_length; // N = (x2 - x1) / (||x2 - x1||)

	float3 relative_velocity = this_particle_velocity - other_particle_velocity; // V = v1 - v2
	float normal_velocity = dot(relative_velocity, normal); // E. = V . N
	float3 tangent_velocity = relative_velocity - normal_velocity * normal; // Vt = V - E. * N
	float tangent_velocity_magnitude = length(tangent_velocity); // vt = ||Vt||

	float normal_force_magnitude = (kd * pow(xi, alpha) * normal_velocity + kr * pow(xi, beta)); // fn + kd * E^alpha * E. + kr * E ^ beta = 0
	float3 normal_force = -normal_force_magnitude * normal;

	if (tangent_velocity_magnitude > 0.f)
	{
		float3 shear_force = -min(_GranularMu * normal_force_magnitude, kt * tangent_velocity_magnitude) * tangent_velocity / tangent_velocity_magnitude;
		contact_force += shear_force;
	}

	contact_force += normal_force;

	return contact_force;
}


// ▼ カーネル関数
//--------------------------------------------------------------------------------------
// 接触力の計算
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void ContactForceCS(uint3 DTid : SV_DispatchThreadID)
{
	const uint P_ID = DTid.x; // 現在処理しているパーティクルID

	float3 P_position = _GranularsBufferRead[P_ID].position;
	float3 P_velocity = _GranularsBufferRead[P_ID].velocity;
	float4 P_orientation = _GranularsBufferRead[P_ID].orientation;
	float3 P_angularVelocity = _GranularsBufferRead[P_ID].angularVelocity;

	float3 Force = float3(0, 0, 0);
	float3 Torque = float3(0, 0, 0);

	// 近傍探索
	LOOP_AROUND_NEIGHBOR(_GranularsBufferRead[P_ID].position)
			{
				unsigned int G_CELL = GridKey(uint3(X, Y, Z)); // Calculate Neighbor (or own) Cell ID

				uint2 G_START_END = _GridIndicesBufferRead[G_CELL];
				for (unsigned int N_ID = G_START_END.x; N_ID < G_START_END.y; N_ID++)
				{
					if (N_ID == P_ID)
						continue; // 自身を計算対象とした場合スキップ
					
					// ▼ MD法による接触力の計算
					
					// https://github.com/WestRyanK/Particle-Simulator/blob/93da771838b3d02f45c3aec964ef4a04bbef6fd4/GranularSimulator/GranularSubstanceSimulator.cpp#L203-L214
					
					float3 N_position = _GranularsBufferRead[N_ID].position;
					float3 N_velocity = _GranularsBufferRead[N_ID].velocity;
					float4 N_orientation = _GranularsBufferRead[N_ID].orientation;
					float3 N_angularVelocity = _GranularsBufferRead[N_ID].angularVelocity;
					
					float3 offset = normalize(N_position - P_position);
					
					for (unsigned int P_particleIndice = 0; P_particleIndice < _GranularParticleNum; P_particleIndice++)
					{
						float3 P_particlePosition = P_position + RotateVector(_ParticleSubstancesBuffer[P_particleIndice].offsetFromGranularCenter, P_orientation);
						float3 P_contact_offset_from_center = _ParticleSubstancesBuffer[P_particleIndice].offsetFromGranularCenter + offset * _ParticleSubstancesBuffer[P_particleIndice].radius;
						float3 P_contact_velocity = P_velocity + cross(P_angularVelocity, P_contact_offset_from_center);
						
						for (unsigned int N_particleIndice = 0; N_particleIndice < _GranularParticleNum; N_particleIndice++)
						{
							float3 N_particlePosition = N_position + RotateVector(_ParticleSubstancesBuffer[N_particleIndice].offsetFromGranularCenter, N_orientation);
							float3 N_contact_offset_from_center = _ParticleSubstancesBuffer[N_particleIndice].offsetFromGranularCenter + offset * _ParticleSubstancesBuffer[N_particleIndice].radius;
							float3 N_contact_velocity = N_velocity + cross(N_angularVelocity, -N_contact_offset_from_center);
							
							float3 contactForce = CalculateContactForce(_ParticleSubstancesBuffer[P_particleIndice].radius,
																		P_particlePosition,
																		P_contact_velocity,
																		_ParticleSubstancesBuffer[N_particleIndice].radius,
																		N_particlePosition,
																		N_contact_velocity);
							float3 contactTorque = cross(P_contact_offset_from_center, contactForce);
							
							Force += contactForce;
							Torque += contactTorque;
						}
					}

					// ▲ ★ここまで

				}
			}
	
	_GranularsBufferWrite[P_ID].acceleration = Force;
	
	// Debug用の処理
	//_DebugBuffer[P_ID] = float4(RotateVector(float3(0.38, 0.38, -0.38), float4(0.01754, -0.04766, 0.18226, 0.98194)), 1);
}


//--------------------------------------------------------------------------------------
// 衝突判定などを行って、位置を更新
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void IntegrateCS(uint3 DTid : SV_DispatchThreadID)
{

	const unsigned int P_ID = DTid.x; // 現在処理しているパーティクルID

	// 更新前情報
	float3 position = _GranularsBufferRead[P_ID].position;
	float3 velocity = _GranularsBufferRead[P_ID].velocity;
	float3 acceleration = _GranularsBufferRead[P_ID].acceleration;
	float4 orientation = _GranularsBufferRead[P_ID].orientation;
	float3 angularVelocity = _GranularsBufferRead[P_ID].angularVelocity;
	float3 angularAcceleration = _GranularsBufferRead[P_ID].angularAcceleration;
	
	uint2 pos = uint2(position.x * _Ratio.x, position.z * _Ratio.z); // Terrain座標（計算用）

	// 重力を付加
	acceleration += _Gravity;
	
	acceleration = acceleration / _GranularTotalMass;
	
	// Rotate moment of inertia tensor
	// https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec26.pdf
	float4x4 rotated_inverse_inertial_moment = (QuaternionToRotateMatrix(orientation) * _GranularInertialMoment) * transpose(QuaternionToRotateMatrix(orientation));
	angularAcceleration = mul(rotated_inverse_inertial_moment, float4(angularAcceleration, 1)).xyz;

	// Terrainとの衝突判定 => 衝突したら壁に沿って移動
	float3 norm;
	float height = GetInterpolatedHeight(position.x * _Ratio.x, position.z * _Ratio.z);
	if (position.y < height)
	{
		position.y = height;
		norm = _TerrainBuffer[pos.x + pos.y * _Resolution].normal; // 法線ベクトル
		velocity = velocity + dot(-velocity, norm) * norm; // 速度ベクトルを壁に沿った向きに変換
		velocity = _Friction * velocity; // 摩擦
	}

	// 前進オイラー法で次の粒子位置を更新
	velocity += _TimeStep * acceleration;
	position += _TimeStep * velocity;
	angularVelocity += _TimeStep * angularAcceleration;
	orientation = mul(orientation, EulerToQuaternion(_TimeStep * angularVelocity));

	// パーティクルのバッファ更新
	_GranularsBufferWrite[P_ID].position = position;
	_GranularsBufferWrite[P_ID].velocity = velocity;
	_GranularsBufferWrite[P_ID].orientation = orientation;
	_GranularsBufferWrite[P_ID].angularVelocity = angularVelocity;

	// Debug用の処理
	//_DebugBuffer[P_ID] = float3(height, 0, 0);
}

// ▲ ★ここまで本体 --------------------------------------
