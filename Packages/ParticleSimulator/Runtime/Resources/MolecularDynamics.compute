#pragma kernel IntegrateCS

// 簡略化のためにスレッド数は1次元にしておく
#define THREAD_SIZE_X 32

#include "./Include/Particle.cginc"
//#include "./Include/Terrain.cginc"
#include "./Include/Math.cginc"

// デバッグ用バッファ
RWStructuredBuffer<float4> _DebugBuffer;

struct ParticleCollisionForce
{
	float3 acceleration;
	float3 angularAcceleration;
};
struct ObjectCollisionForce
{
	float3 acceleration;
	float3 angularAcceleration;
};
struct TerrainCollisionForce
{
	float3 acceleration;
	float3 angularAcceleration;
};

RWStructuredBuffer<ParticleCollisionForce> _ParticleCollisionForce;
RWStructuredBuffer<ObjectCollisionForce> _ObjectCollisionForce;
RWStructuredBuffer<TerrainCollisionForce> _TerrainCollisionForce;

// ▼ シェーダ定数の定義 -----------------------
cbuffer MolecularDynamicsCB
{
	float _TimeStep; // 時間刻み幅(dt)
	float3 _Gravity; // 重力
};
// ▲ シェーダ定数の定義 -----------------------


//--------------------------------------------------------------------------------------
// Update particle state
//--------------------------------------------------------------------------------------
[numthreads(THREAD_SIZE_X, 1, 1)]
void IntegrateCS(uint3 DTid : SV_DispatchThreadID)
{
	const unsigned int P_ID = DTid.x; // 現在処理しているパーティクルID
	
	// 更新前情報
	ParticleType particle = _ParticleBufferRead[P_ID];
	ParticleCollisionForce pcf = _ParticleCollisionForce[P_ID];
	ObjectCollisionForce ocf = _ObjectCollisionForce[P_ID];
	TerrainCollisionForce tcf = _TerrainCollisionForce[P_ID];
	
	// 重力を付加
	float3 acceleration = _Gravity;
	acceleration += (pcf.acceleration + ocf.acceleration + tcf.acceleration);
	acceleration = acceleration / _ParticleTotalMass;
	
	// Rotate moment of inertia tensor
	// https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-07-dynamics-fall-2009/lecture-notes/MIT16_07F09_Lec26.pdf
	float3 angularAcceleration = (pcf.angularAcceleration + ocf.angularAcceleration + tcf.angularAcceleration);
	float4x4 rotated_inverse_inertial_moment = (QuaternionToRotateMatrix(particle.orientation) * _ParticleInertialMoment) * transpose(QuaternionToRotateMatrix(particle.orientation));
	angularAcceleration = mul(rotated_inverse_inertial_moment, float4(angularAcceleration, 1)).xyz;

	// 前進オイラー法で次の粒子位置を更新
	particle.velocity += _TimeStep * acceleration;
	particle.position += _TimeStep * particle.velocity;
	particle.angularVelocity += _TimeStep * angularAcceleration;
	particle.orientation = mul(particle.orientation, EulerToQuaternion(_TimeStep * particle.angularVelocity));

	// パーティクルのバッファ更新
	_ParticleBufferWrite[P_ID] = particle;
	
	// Debug用の処理
	//_DebugBuffer[P_ID] = float3(height, 0, 0);
}
